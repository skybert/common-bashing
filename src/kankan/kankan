#! /usr/bin/env bash

declare -a url_list_200_ok_and_xml=()
number_of_errors=0
number_of_tests=0

declare -a required_commands=(
  curl
  xmllint
  sed
)

ensure_sanity() {
  local errors_detected=0
  for required_command in "${required_commands[@]}"; do
    which "${required_command}" &> /dev/null || {
      printf "%s\n" "${0##*/} needs the command ${required_command} ðŸ’€"
      errors_detected=1
    }
  done

  if [ "${errors_detected}" -eq 1 ]; then
    exit 1
  fi

}

show_help_and_exit() {
  cat <<EOF
Usage: ${0##*/} OPTIONS

Easy integration tests for UNIX folks.

Reports of each run is stored in $HOME/.${0##*/} These can be turned
off with --disable-logs.

OPTIONS
-d, --disable-logs  Don't create log files for each run
-h, --help          This screen.
-p, --print-checks  List all the checks ${0##*/} has run
-v, --verbose       Be verbose
EOF
  exit 0
}

read_user_input() {
  local OPTS=
  OPTS=$(getopt \
           -o hvpd \
           --long verbose \
           --long print-checks \
           --long disable-logs \
           --long help \
           -n 'parse-options' \
           -- "$@")
  if [ $? != 0 ] ; then
    echo "Failed parsing options." >&2
    exit 1
  fi
  eval set -- "$OPTS"

  while true; do
    case "$1" in
      -h | --help )
        show_help_and_exit;
        break;;
      -d | --disable-logs )
        disable_log_files=1
        break;;
      -v | --verbose )
        verbose=1;
        break;;
      -p | --print-checks )
        print_checks=1;
        break;;
      -- )
        shift;
        break ;;
      * )
        break ;;
    esac
  done

  rest_of_args=$*
}

flag_error() {
  echo -n "E"

  local message=$*
  message=$(
    echo "$*" | sed -r 's#http://(.*:.*@)#http://#')

  if [ -n "${errors}" ]; then
    errors="${errors}
   â˜  ${FUNCNAME[1]} ${message}"
  else
    errors="   â˜  ${FUNCNAME[1]} ${message}"
  fi

  ((number_of_errors++))
}

print_report() {
  if [ -n "${errors}" ]; then
    echo -e "\n${errors}" | sort
  else
    echo ""
  fi

  echo "Tests run:" \
       "$(blue $((number_of_tests)));" \
       "success: $(green $((number_of_tests - number_of_errors)));" \
       "error: $(red ${number_of_errors});"

  if [ "${print_checks-0}" -eq 1 ]; then
    printf "\n%s\n" "Checks executed:"
    printf "%s\n" "${checks_executed[@]}" |
      sed 's#^check_that_#  - #' |
      sed 's#^check_#  - #' |
      sort
    printf "\n"
  fi

}

bootstrap_thyself() {
  source $(dirname "$0")/../common/text/color.sh || {
    echo "I need my colours, even with a 'u'"
    exit 1
  }
}

check_list_of_urls_that_should_return_200() {
  if [ "${has_initialised_ece_instance_check}" -eq 0 ]; then
    init_check_ece_instances
  fi

  _tmp=$(declare -p url_list_200_ok_and_xml)
  eval "declare -a url_list_200_ok_and_xml=${_tmp#*=}"

  for el in "${url_list_200_ok_and_xml[@]}"; do
    ((number_of_tests++))
    local uri_fragment=${el##http://${host_and_port}}

    if [ "${verbose-0}" -eq 1 ]; then
      echo "Verifying 200 OK and well formed XML: ${uri_fragment} ..."
    else
      echo -n "."
    fi

    curl -s -I "${el}" | grep --quiet "^HTTP/1.1 200 OK"
    if [ $? -ne 0 ]; then
      flag_error "${uri_fragment} did NOT return 200 OK"
      continue
    fi

    curl -s "${el}" | xmllint --format - > /dev/null || {
      flag_error "${uri_fragment} isn't well formed XML"
    }
  done
}

main() {
  ensure_sanity
  bootstrap_thyself
  read_user_input "$@"

  # create_conf
  local file=
  file="$HOME/.$(basename "$0").conf"

  source -- "${file}" || {
    echo "You need a ${file}"
    exit 1
  }


  for f in "$(dirname "$0")/checks/"*.sh; do
    source "${f}" || exit 1
  done

  local -a checks_executed=()

  for check_method in $(declare -f | grep ^check_ | awk '{print $1}' | sort); do
    ((number_of_tests++))
    ${check_method}
    echo -n "."
    checks_executed=(
      "${check_method}"
      "${checks_executed[@]}"
    )
  done

  if [ ${disable_log_files-0} -eq 0 ]; then
    mkdir -p "${HOME}/.kankan"
    print_report |
      tee "$HOME/.kankan/$(date --iso)-$(date +%s)-results.txt"
  else
    print_report
  fi
}

main "$*"
